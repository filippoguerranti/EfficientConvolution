switch (orderNumber) {
    case 1: // Convolution (Order N. 1)
    if constexpr (LLVM_NAIVE_1) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_1 ");
    for(auto i = 0; i < Ci; i++) {
        for(auto j = 0; j < Co; j++) {
            for(auto k = 0; k < Wo; k++) {
                for(auto l = 0; l < Ho; l++) {
                    for(auto m = 0; m < Wf; m++) {
                        for(auto n = 0; n < Hf; n++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                        }
                    }
                }
            }
            // std::cout << "----- j\n";   
        }
    }
    if constexpr (LLVM_NAIVE_1) __asm volatile (" #LLVM-MCA-END convolveNaive_1 ");
    break;

    case 2: // Convolution (Order N. 2)
    if constexpr (LLVM_NAIVE_2) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_2 ");
    for(auto l = 0; l < Ho; l++) {
        for(auto n = 0; n < Hf; n++) {
            for(auto m = 0; m < Wf; m++) {
                    for(auto k = 0; k < Wo; k++) {
                for(auto i = 0; i < Ci; i++) {
                        for(auto j = 0; j < Co; j++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (j * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_2) __asm volatile (" #LLVM-MCA-END convolveNaive_2 ");
    break;

    case 20: // Convolution (Order N. 2)
    for(auto l = 0; l < Ho; l++) {  
        for(auto n = 0; n < Hf; n++) {
            for(auto m = 0; m < Wf; m++) {
                for(auto i = 0; i < Ci; i++) {
                    for(auto k = 0; k < Wo; k++) {
                        for(auto j = 0; j < Co-4; j+=4) {
                            auto Wi_idx = (k*stride) + m;
                            auto Hi_idx = (l*stride) + n;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            // (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                            __m128* outputSSE = (__m128*) &(*output)[outputIndex];
                            __m128* kernelSSE = (__m128*) &(*kernel)[kernelIndex];
                            __m128 inputScalar  = _mm_set1_ps((*this)[inputIndex]);                    
                            _mm_store_ps(&(*output)[outputIndex], (_mm_fmadd_ps(inputScalar, *kernelSSE, *outputSSE)));
                            // std::cout << "j: " << j << std::endl;
                        }
                    }
                }
            }
        }
    }
    break;

    case 3: // Convolution (Order N. 3)
    if constexpr (LLVM_NAIVE_3) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_3 ");
    for(auto l = 0; l < Ho; l++) {
        for(auto k = 0; k < Wo; k++) {
            for(auto j = 0; j < Co; j++) {
                for(auto n = 0; n < Hf; n++) {
                    for(auto m = 0; m < Wf; m++) {
                        for(auto i = 0; i < Ci; i++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];

                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_3) __asm volatile (" #LLVM-MCA-END convolveNaive_3 ");
    break;

    case 4: // Convolution (Order N. 4)
    if constexpr (LLVM_NAIVE_4) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_4 ");
    for(auto k = 0; k < Wo; k++) {
        for(auto j = 0; j < Co; j++) {
            for(auto l = 0; l < Ho; l++) {
                for(auto n = 0; n < Hf; n++) {
                    for(auto m = 0; m < Wf; m++) {
                        for(auto i = 0; i < Ci; i++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_4) __asm volatile (" #LLVM-MCA-END convolveNaive_4 ");
    break;

    case 5: // Convolution (Order N. 5)
    if constexpr (LLVM_NAIVE_5) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_5 ");
    for(auto k = 0; k < Wo; k++) {
        for(auto j = 0; j < Co; j++) {
            for(auto n = 0; n < Hf; n++) {
                for(auto m = 0; m < Wf; m++) {
                    for(auto i = 0; i < Ci; i++) {
                        for(auto l = 0; l < Ho; l++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_5) __asm volatile (" #LLVM-MCA-END convolveNaive_5 ");
    break;

    case 6: // Convolution (Order N. 6)
    if constexpr (LLVM_NAIVE_6) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_6 ");
    for(auto n = 0; n < Hf; n++) {
        for(auto m = 0; m < Wf; m++) {
            for(auto i = 0; i < Ci; i++) {
                for(auto k = 0; k < Wo; k++) {
                    for(auto j = 0; j < Co; j++) {
                        for(auto l = 0; l < Ho; l++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_6) __asm volatile (" #LLVM-MCA-END convolveNaive_6 ");
    break;

    case 7: // Convolution (Order N. 7)
    if constexpr (LLVM_NAIVE_7) __asm volatile (" #LLVM-MCA-BEGIN convolveNaive_7 ");
    for(auto n = 0; n < Hf; n++) {
        for(auto m = 0; m < Wf; m++) {
            for(auto i = 0; i < Ci; i++) {
                for(auto l = 0; l < Ho; l++) {
                    for(auto k = 0; k < Wo; k++) {
                        for(auto j = 0; j < Co; j++) {
                            auto Hi_idx = (l*stride) + n;
                            auto Wi_idx = (k*stride) + m;
                            // Compute indexes
                            auto inputIndex = (Hi_idx * this->width * this->nChannels) + (Wi_idx * this->nChannels) + i;
                            auto outputIndex = (l * output->width * output->nChannels) + (k * output->nChannels) + j;
                            auto kernelIndex = (n * kernel->width * kernel->nElements * kernel->nChannels) + (m * kernel->nElements * kernel->nChannels) + (i * kernel->nElements) + j;
                            // Accumualate on output elements
                            (*output)[outputIndex] += (*this)[inputIndex] * (*kernel)[kernelIndex];
                            
                        }
                    }
                }
            }
        }
    }
    if constexpr (LLVM_NAIVE_7) __asm volatile (" #LLVM-MCA-END convolveNaive_7 ");
    break;